
import { DeviceCharacteristic, DeviceInterface, DeviceMethod, DeviceParameter, DeviceProperty }
    from "./DeviceInterface";
import { IDeviceInterfaceConverter } from "./IDeviceInterfaceConverter";
import { Schema } from "jsonschema";

import * as fs from "fs";
import * as path from "path";

/**
 * Reads and writes device interface specifications in TypeScript type-definition format.
 */
export class TypeScriptConverter implements IDeviceInterfaceConverter {
    public readAsync(sourceFilePath: string): Promise<DeviceInterface> {
        return new Promise<DeviceInterface>((resolve, reject) => {
            reject(new Error("not implemented"));
        });
    }

    public async writeAsync(deviceInterface: DeviceInterface, targetDirectoryPath: string): Promise<void> {

        let ts = "// Generated by OpenT2T\n";

        let fullName = deviceInterface.name;
        let className = fullName.substr(fullName.lastIndexOf('.') + 1);
        let ns = className.length < fullName.length ?
                fullName.substr(0, fullName.length - className.length - 1) : null;
        if (ns) {
            ts += "namespace " + ns + " {\n";
        }

        ts += "  export interface " + className + " {\n\n";

        deviceInterface.properties.forEach((p: DeviceProperty) => {
            if (p.canRead || p.canWrite) {
                ts += this.writeProperty(p) + "\n";
            }
        });

        deviceInterface.methods.forEach((m: DeviceMethod) => {
            ts += this.writeMethod(m);
        });

        deviceInterface.properties.forEach((p: DeviceProperty) => {
            if (p.canNotify) {
                ts += this.writeSignal(p);
            }
        });

        ts += "  }\n";

        if (ns) {
            ts += "}\n";
        }

        await new Promise<void>((resolve, reject) => {
            fs.writeFile(path.join(targetDirectoryPath, fullName + ".ts"), ts, (err: Error) => {
                err ? reject(err) : resolve();
            });
        });
    }

    private writeProperty(property: DeviceProperty): string {
        let comment = this.writeDescription(property);
        let type = this.jsonSchemaToTypeScriptType(property.propertyType);
        if (property.canRead && !property.canWrite) {
            return comment + "    readonly " + property.name + ": " + type + ";\n";
        } else {
            // TypeScript doesn't support write-only property in interfaces.
            return comment + "    " + property.name + ": " + type + ";\n";
        }
    }

    private writeSignal(signal: DeviceProperty): string {
        let type = this.jsonSchemaToTypeScriptType(signal.propertyType);
        let capitalName = TypeScriptConverter.capitalize(signal.name);
        let comment = (signal.canRead || signal.canWrite) ?
            "    /**\n     * Register a callback for " + signal.name + " notifications\n     */\n" :
            this.writeDescription(signal);
        return comment +
            "    add" + capitalName + "Listener(callback: (value: " + type + ") => void): void;\n" +
            "    remove" + capitalName + "Listener(callback: (value: " + type + ") => void): void;\n\n";
    }

    private writeMethod(method: DeviceMethod): string {
        let comment = this.writeDescription(method);
        let parameters = "";
        let returnType = "void";

        method.parameters.forEach((p: DeviceParameter) => {
            if (p.isOut) {
                if (returnType !== "void") {
                    throw new Error("Multiple out parameters are not supported");
                } else {
                    returnType = this.jsonSchemaToTypeScriptType(p.parameterType);
                }
            } else {
                if (parameters) {
                    parameters += ", ";
                }

                parameters += p.name + ": " + this.jsonSchemaToTypeScriptType(p.parameterType);
            }
        });

        return comment + "    " + method.name + "(" + parameters + "): " + returnType + ";\n\n";
    }

    private writeDescription(characteristic: DeviceCharacteristic): string {
        if (!characteristic.description) {
            return "";
        }

        return "    /**\n     * " + characteristic.description + "\n     */\n";
    }

    public jsonSchemaToTypeScriptType(schema: Schema): string {
        if (!schema || !schema.type) {
            return "any";
        }

        // TODO: Support complex types
        switch(schema.type) {
            case "integer":
            case "number": return "number";
            case "string": return "string";
            case "boolean": return "boolean";
            case "array": return "array";
            default: return "any";
        }
    }

    public typeScriptTypeToJsonSchema(type: string): Schema {
        throw new Error("Not implemented");
    }

    private static capitalize(name: string) {
        if (name.length > 1) {
            return name.substr(0, 1).toUpperCase() + name.substr(1);
        }

        return name;
    }
}
